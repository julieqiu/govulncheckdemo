govulncheck is an experimental tool. Share feedback at https://go.dev/s/govulncheck-feedback.

Using go1.18 and govulncheck@v0.0.0 with
vulnerability data from https://vuln.go.dev (last modified 15 Mar 23 23:31 UTC).

Scanning your code and 122 packages across 0 dependent modules for known vulnerabilities...
Your code is affected by 7 vulnerabilities from the Go standard library.

Vulnerability #1: GO-2023-1571
  A maliciously crafted HTTP/2 stream could cause excessive CPU
  consumption in the HPACK decoder, sufficient to cause a denial
  of service from a small number of small requests.

  More info: https://pkg.go.dev/vuln/GO-2023-1571

  Standard library
    Found in: net/http@go1.18
    Fixed in: net/http@go1.20.1

    Call stacks in your code:
      github.com/julieqiu/govulncheckdemo/module6.init calls net/http.init
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2ConnectionError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2ErrCode.String
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2FrameHeader.String
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2FrameType.String
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2GoAwayError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2Setting.String
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2SettingID.String
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2StreamError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2connError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2duplicatePseudoHeaderError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2headerFieldNameError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2headerFieldValueError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2httpError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2noCachedConnError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2pseudoHeaderError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.http2writeData.String
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.httpError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.socksAddr.String
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.tlsHandshakeTimeoutError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.transportReadFromServerError.Error
      main.go:11:14: github.com/julieqiu/govulncheckdemo/module6.main calls fmt.Println, which eventually calls net/http.unsupportedTEError.Error
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get

Vulnerability #2: GO-2023-1570
  Large handshake records may cause panics in crypto/tls. Both
  clients and servers may send large TLS handshake records which
  cause servers and clients, respectively, to panic when
  attempting to construct responses. This affects all TLS 1.3
  clients, TLS 1.2 clients which explicitly enable session
  resumption (by setting Config.ClientSessionCache to a non-nil
  value), and TLS 1.3 servers which request client certificates
  (by setting Config.ClientAuth >= RequestClientCert).

  More info: https://pkg.go.dev/vuln/GO-2023-1570

  Standard library
    Found in: crypto/tls@go1.18
    Fixed in: crypto/tls@go1.20.1

    Call stacks in your code:
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get, which eventually calls crypto/tls.Conn.Read
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get, which eventually calls crypto/tls.Conn.Write
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get, which eventually calls crypto/tls.Dialer.DialContext

Vulnerability #3: GO-2022-0525
  The HTTP/1 client accepted some invalid Transfer-Encoding
  headers as indicating a "chunked" encoding. This could
  potentially allow for request smuggling, but only if combined
  with an intermediate server that also improperly failed to
  reject the header as invalid.

  More info: https://pkg.go.dev/vuln/GO-2022-0525

  Standard library
    Found in: net/http@go1.18
    Fixed in: net/http@go1.18.4

    Call stacks in your code:
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get

Vulnerability #4: GO-2022-0524
  Calling Reader.Read on an archive containing a large number of
  concatenated 0-length compressed files can cause a panic due to
  stack exhaustion.

  More info: https://pkg.go.dev/vuln/GO-2022-0524

  Standard library
    Found in: compress/gzip@go1.18
    Fixed in: compress/gzip@go1.18.4

    Call stacks in your code:
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get, which eventually calls compress/gzip.Reader.Read

Vulnerability #5: GO-2022-0520
  Client IP adresses may be unintentionally exposed via
  X-Forwarded-For headers. When httputil.ReverseProxy.ServeHTTP is
  called with a Request.Header map containing a nil value for the
  X-Forwarded-For header, ReverseProxy sets the client IP as the
  value of the X-Forwarded-For header, contrary to its
  documentation. In the more usual case where a Director function
  sets the X-Forwarded-For header value to nil, ReverseProxy
  leaves the header unmodified as expected.

  More info: https://pkg.go.dev/vuln/GO-2022-0520

  Standard library
    Found in: net/http@go1.18
    Fixed in: net/http@go1.18.4

    Call stacks in your code:
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get

Vulnerability #6: GO-2022-0435
  A crafted scalar input longer than 32 bytes can cause
  P256().ScalarMult or P256().ScalarBaseMult to panic. Indirect
  uses through crypto/ecdsa and crypto/tls are unaffected. amd64,
  arm64, ppc64le, and s390x are unaffected.

  More info: https://pkg.go.dev/vuln/GO-2022-0435

  Standard library
    Found in: crypto/elliptic@go1.18
    Fixed in: crypto/elliptic@go1.18.1

    Call stacks in your code:
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get, which eventually calls crypto/elliptic.GenerateKey
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get, which eventually calls crypto/elliptic.p256Curve.CombinedMult
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get, which eventually calls crypto/elliptic.p256Curve.ScalarMult

Vulnerability #7: GO-2022-0434
  Verifying certificate chains containing certificates which are
  not compliant with RFC 5280 causes Certificate.Verify to panic
  on macOS. These chains can be delivered through TLS and can
  cause a crypto/tls or net/http client to crash.

  More info: https://pkg.go.dev/vuln/GO-2022-0434

  Standard library
    Found in: crypto/x509@go1.18
    Fixed in: crypto/x509@go1.18.1
    Platforms: darwin

    Call stacks in your code:
      main.go:9:20: github.com/julieqiu/govulncheckdemo/module6.main calls net/http.Get, which eventually calls crypto/x509.Certificate.Verify

=== Informational ===

Found 14 vulnerabilities in packages that you import, but there are no call
stacks leading to the use of these vulnerabilities. You may not need to
take any action. See https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck
for details.

Vulnerability #1: GO-2023-1569
  A denial of service is possible from excessive resource
  consumption in net/http and mime/multipart. Multipart form
  parsing with mime/multipart.Reader.ReadForm can consume largely
  unlimited amounts of memory and disk files. This also affects
  form parsing in the net/http package with the Request methods
  FormFile, FormValue, ParseMultipartForm, and PostFormValue.
  ReadForm takes a maxMemory parameter, and is documented as
  storing "up to maxMemory bytes +10MB (reserved for non-file
  parts) in memory". File parts which cannot be stored in memory
  are stored on disk in temporary files. The unconfigurable 10MB
  reserved for non-file parts is excessively large and can
  potentially open a denial of service vector on its own. However,
  ReadForm did not properly account for all memory consumed by a
  parsed form, such as map entry overhead, part names, and MIME
  headers, permitting a maliciously crafted form to consume well
  over 10MB. In addition, ReadForm contained no limit on the
  number of disk files created, permitting a relatively small
  request body to create a large number of disk temporary files.
  With fix, ReadForm now properly accounts for various forms of
  memory overhead, and should now stay within its documented limit
  of 10MB + maxMemory bytes of memory consumption. Users should
  still be aware that this limit is high and may still be
  hazardous. In addition, ReadForm now creates at most one on-disk
  temporary file, combining multiple form parts into a single
  temporary file. The mime/multipart.File interface type's
  documentation states, "If stored on disk, the File's underlying
  concrete type will be an *os.File.". This is no longer the case
  when a form contains more than one file part, due to this
  coalescing of parts into a single file. The previous behavior of
  using distinct files for each form part may be reenabled with
  the environment variable GODEBUG=multipartfiles=distinct. Users
  should be aware that multipart.ReadForm and the http.Request
  methods that call it do not limit the amount of disk consumed by
  temporary files. Callers can limit the size of form data with
  http.MaxBytesReader.
  More info: https://pkg.go.dev/vuln/GO-2023-1569
  Found in: mime/multipart@go1.18
  Fixed in: mime/multipart@go1.20.1

Vulnerability #2: GO-2023-1568
  A path traversal vulnerability exists in filepath.Clean on
  Windows. On Windows, the filepath.Clean function could transform
  an invalid path such as "a/../c:/b" into the valid path "c:\b".
  This transformation of a relative (if invalid) path into an
  absolute path could enable a directory traversal attack. After
  fix, the filepath.Clean function transforms this path into the
  relative (but still invalid) path ".\c:\b".
  More info: https://pkg.go.dev/vuln/GO-2023-1568
  Found in: path/filepath@go1.18
  Fixed in: path/filepath@go1.20.1
  Platforms: windows

Vulnerability #3: GO-2022-1144
  An attacker can cause excessive memory growth in a Go server
  accepting HTTP/2 requests. HTTP/2 server connections contain a
  cache of HTTP header keys sent by the client. While the total
  number of entries in this cache is capped, an attacker sending
  very large keys can cause the server to allocate approximately
  64 MiB per open connection.
  More info: https://pkg.go.dev/vuln/GO-2022-1144
  Found in: net/http@go1.18
  Fixed in: net/http@go1.19.4

Vulnerability #4: GO-2022-1143
  On Windows, restricted files can be accessed via os.DirFS and
  http.Dir. The os.DirFS function and http.Dir type provide access
  to a tree of files rooted at a given directory. These functions
  permit access to Windows device files under that root. For
  example, os.DirFS("C:/tmp").Open("COM1") opens the COM1 device.
  Both os.DirFS and http.Dir only provide read-only filesystem
  access. In addition, on Windows, an os.DirFS for the directory
  (the root of the current drive) can permit a maliciously crafted
  path to escape from the drive and access any path on the system.
  With fix applied, the behavior of os.DirFS("") has changed.
  Previously, an empty root was treated equivalently to "/", so
  os.DirFS("").Open("tmp") would open the path "/tmp". This now
  returns an error.
  More info: https://pkg.go.dev/vuln/GO-2022-1143
  Found in: net/http@go1.18
  Fixed in: net/http@go1.19.4
  Platforms: windows

Vulnerability #5: GO-2022-1095
  Due to unsanitized NUL values, attackers may be able to
  maliciously set environment variables on Windows. In
  syscall.StartProcess and os/exec.Cmd, invalid environment
  variable values containing NUL values are not properly checked
  for. A malicious environment variable value can exploit this
  behavior to set a value for a different environment variable.
  For example, the environment variable string "A=B\x00C=D" sets
  the variables "A=B" and "C=D".
  More info: https://pkg.go.dev/vuln/GO-2022-1095
  Found in: syscall@go1.18
  Fixed in: syscall@go1.19.3
  Platforms: windows

Vulnerability #6: GO-2022-0969
  HTTP/2 server connections can hang forever waiting for a clean
  shutdown that was preempted by a fatal error. This condition can
  be exploited by a malicious client to cause a denial of service.
  More info: https://pkg.go.dev/vuln/GO-2022-0969
  Found in: net/http@go1.18
  Fixed in: net/http@go1.19.1

Vulnerability #7: GO-2022-0537
  Decoding big.Float and big.Rat types can panic if the encoded
  message is too short, potentially allowing a denial of service.
  More info: https://pkg.go.dev/vuln/GO-2022-0537
  Found in: math/big@go1.18
  Fixed in: math/big@go1.18.5

Vulnerability #8: GO-2022-0533
  On Windows, the filepath.Clean function can convert certain
  invalid paths to valid, absolute paths, potentially allowing a
  directory traversal attack. For example, Clean(`.\c:`) returns
  `c:`.
  More info: https://pkg.go.dev/vuln/GO-2022-0533
  Found in: path/filepath@go1.18
  Fixed in: path/filepath@go1.18.3
  Platforms: windows

Vulnerability #9: GO-2022-0531
  An attacker can correlate a resumed TLS session with a previous
  connection. Session tickets generated by crypto/tls do not
  contain a randomly generated ticket_age_add, which allows an
  attacker that can observe TLS handshakes to correlate successive
  connections by comparing ticket ages during session resumption.
  More info: https://pkg.go.dev/vuln/GO-2022-0531
  Found in: crypto/tls@go1.18
  Fixed in: crypto/tls@go1.18.3

Vulnerability #10: GO-2022-0527
  Calling Glob on a path which contains a large number of path
  separators can cause a panic due to stack exhaustion.
  More info: https://pkg.go.dev/vuln/GO-2022-0527
  Found in: io/fs@go1.18
  Fixed in: io/fs@go1.18.4

Vulnerability #11: GO-2022-0522
  Calling Glob on a path which contains a large number of path
  separators can cause a panic due to stack exhaustion.
  More info: https://pkg.go.dev/vuln/GO-2022-0522
  Found in: path/filepath@go1.18
  Fixed in: path/filepath@go1.18.4

Vulnerability #12: GO-2022-0493
  When called with a non-zero flags parameter, the Faccessat
  function can incorrectly report that a file is accessible.
  More info: https://pkg.go.dev/vuln/GO-2022-0493
  Found in: syscall@go1.18
  Fixed in: syscall@go1.18.2

Vulnerability #13: GO-2022-0477
  On Windows, rand.Read will hang indefinitely if passed a buffer
  larger than 1 << 32 - 1 bytes.
  More info: https://pkg.go.dev/vuln/GO-2022-0477
  Found in: crypto/rand@go1.18
  Fixed in: crypto/rand@go1.18.3
  Platforms: windows

Vulnerability #14: GO-2022-0433
  encoding/pem in Go before 1.17.9 and 1.18.x before 1.18.1 has a
  Decode stack overflow via a large amount of PEM data.
  More info: https://pkg.go.dev/vuln/GO-2022-0433
  Found in: encoding/pem@go1.18
  Fixed in: encoding/pem@go1.18.1
